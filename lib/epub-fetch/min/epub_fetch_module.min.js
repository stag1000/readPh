
define('models/fetch_base',['backbone'], function (Backbone) {

    var EpubFetchBase = Backbone.Model.extend({
        _handleError: function (err) {
            console.log(err);
            console.trace();
        },
        parseXml: function (xmlString) {
            return this.parseMarkup(xmlString, 'text/xml');
        },
        parseMarkup: function (markupString, contentType) {
            var parser = new window.DOMParser;
            var parsedDom = parser.parseFromString(markupString, contentType);
            return parsedDom;
        }
    });

    return EpubFetchBase;
});

define('models/discover_content_type',['require', 'module', 'jquery', 'backbone', 'URIjs/URI'], function (require, module, $, Backbone, URI) {
    console.log('discover_content_type module id: ' + module.id);

    var ContentTypeDiscovery = Backbone.Model.extend({

        initialize: function (attributes) {
        },

        identifyContentTypeFromFileName: function (contentUrl) {
            var contentUrlSuffix = URI(contentUrl).suffix();
            var contentType = 'application/octet-stream';
            if (typeof this.constructor.suffixContentTypeMap[contentUrlSuffix] !== 'undefined') {
                contentType = this.constructor.suffixContentTypeMap[contentUrlSuffix];
            }
            return contentType;
        },

        identifyContentType: function () {
            // TODO: Make the call asynchronous (which would require a callback and would probably make sense
            // when calling functions are also remodelled for async).
            var contentUrl = this.get('contentUrl');
            var contentType = $.ajax({
                type: "HEAD",
                url: contentUrl,
                async: false
            }).getResponseHeader('Content-Type');
            if (contentType === null) {
                contentType = this.identifyContentTypeFromFileName(contentUrl);
                console.log('guessed contentType [' + contentType + '] from URI [' + contentUrl +
                    ']. Configuring the web server to provide the content type is recommended.');

            }
            return contentType;
        }

    }, {
        suffixContentTypeMap: {
            css: 'text/css',
            epub: 'application/epub+zip',
            gif: 'image/gif',
            html: 'text/html',
            jpg: 'image/jpeg',
            jpeg: 'image/jpeg',
            ncx: 'application/x-dtbncx+xml',
            opf: 'application/oebps-package+xml',
            png: 'image/png',
            svg: 'image/svg+xml',
            xhtml: 'application/xhtml+xml'
        }
    });

    return ContentTypeDiscovery;
});

define('models/plain_fetcher',['require', 'module', 'jquery', 'URIjs/URI', './fetch_base'], function (require, module, $, URI, EpubFetchBase) {
    console.log('plain_fetcher module id: ' + module.id);

    var PlainExplodedFetcher = EpubFetchBase.extend({

        initialize: function (attributes) {
        },

        // Plain exploded EPUB packages are exploded by definition:
        isExploded: function () {
            return true;
        },

        resolveURI: function (epubResourceURI) {
            // Make absolute to the package document path
            var epubResourceRelURI = new URI(epubResourceURI);
            var epubResourceAbsURI = epubResourceRelURI.absoluteTo(this.get('baseUrl'));
            return epubResourceAbsURI.toString();
        },

        fetchFileContentsText: function (fileUrl, fetchCallback, onerror) {
            var thisFetcher = this;
            $.ajax({
                url: fileUrl,
                dataType: 'text',
                success: function (result) {
                    fetchCallback(result);
                },
                error: function (xhr, status, errorThrown) {
                    console.log('Error when AJAX fetching ' + fullUrl);
                    console.log(status);
                    console.log(errorThrown);
                    onerror(errorThrown);
                }
            });
        },

        relativeToPackageFetchFileContents: function (relativeToPackagePath, fetchMode, fetchCallback, onerror) {
            // Not translating relativeToPackagePath, as with exploded EPUB all the URLs are relative
            // to the current page context and are good to go verbatim for fetching:
            this.fetchFileContentsText(relativeToPackagePath, fetchCallback, onerror);
        },

        getPackageDom: function (callback) {
            console.log('getting package DOM');

            var thisFetcher = this;
            var baseUrl = thisFetcher.get('baseUrl');
            console.log('baseUrl: ' + baseUrl);

            thisFetcher.fetchFileContentsText(baseUrl, function (packageXml) {
                var packageDom = thisFetcher.parseXml(packageXml);
                callback(packageDom);
            }, this._handleError);
        }
    });
    return PlainExplodedFetcher;
});
define('models/zip_fetcher',['require', 'module', 'jquery', 'URIjs/URI', './fetch_base'], function (require, module, $, URI, EpubFetchBase) {
    console.log('zip_fetcher module id: ' + module.id);

    var ZipFetcher = EpubFetchBase.extend({

        defaults: {
            'checkCrc32': false
        },

        initialize: function (attributes) {
        },

        // Description: perform a function with an initialized zip filesystem, making sure that such filesystem is initialized.
        // Note that due to a race condition, more than one zip filesystem may be instantiated.
        // However, the last one to be set on the model object will prevail and others would be garbage collected later.
        _withZipFsPerform: function (callback, onerror) {
            var thisFetcher = this;
            if (thisFetcher.has('_zipFs')) {
                var zipFs = thisFetcher.get('_zipFs');
                callback(zipFs);

            } else {
                var zipUrl = thisFetcher.get('baseUrl');
                var libDir = thisFetcher.get('libDir');
                console.log('zip.workerScriptsPath = ' + libDir);
                zip.workerScriptsPath = libDir;
                var zipFs = new zip.fs.FS();
                zipFs.importHttpContent(zipUrl, true, function () {
                    thisFetcher.set('_zipFs', zipFs);
                    callback(zipFs);

                }, onerror)
            }
        },

        _identifyContentTypeFromFileName: function (fileUri) {
            return this.get('_contentTypeDiscovery').identifyContentTypeFromFileName(fileUri);
        },

        // Zipped EPUB packages are not exploded by definition:
        isExploded: function () {
            return false;
        },

        resolveURI: function (epubResourceURI) {
            return epubResourceURI;
        },

        fetchFileContents: function (relativePath, readCallback, onerror) {
            var thisFetcher = this;
            this._withZipFsPerform(function (zipFs) {
                var entry = zipFs.find(relativePath);
                if (typeof entry === 'undefined' || entry === null) {
                    onerror(new Error('Entry ' + relativePath + ' not found in zip ' + thisFetcher.get('baseUrl')));
                } else {
                    if (entry.directory) {
                        onerror(new Error('Entry ' + relativePath + ' is a directory while a file has been expected'));
                    } else {
                        readCallback(entry);
                    }
                }
            }, thisFetcher._handleError);
        },

        fetchFileContentsText: function (relativePath, fetchCallback, onerror) {
            var thisFetcher = this;
            thisFetcher.fetchFileContents(relativePath, function (entry) {
                entry.getText(fetchCallback, undefined, thisFetcher.get('checkCrc32'));
            }, onerror)
        },

        fetchFileContentsData64Uri: function (relativePath, fetchCallback, onerror) {
            var thisFetcher = this;
            thisFetcher.fetchFileContents(relativePath, function (entry) {
                entry.getData64URI(thisFetcher._identifyContentTypeFromFileName(relativePath), fetchCallback, undefined,
                    thisFetcher.get('checkCrc32'));
            }, onerror)
        },

        fetchFileContentsBlob: function (relativePath, fetchCallback, onerror) {
            var thisFetcher = this;
            thisFetcher.fetchFileContents(relativePath, function (entry) {
                entry.getBlob(thisFetcher._identifyContentTypeFromFileName(relativePath), fetchCallback, undefined,
                    thisFetcher.get('checkCrc32'));
            }, onerror)
        },

        relativeToPackageFetchFileContents: function (relativeToPackagePath, fetchMode, fetchCallback, onerror) {
            var thisFetcher = this;
            var packageFullPath = thisFetcher.get('_packageFullPath');
            console.log('Have got _packageFullPath ' + packageFullPath);
            console.log('packageFullPath: ' + packageFullPath);
            console.log('relativePath: ' + relativeToPackagePath);
            var pathRelativeToPackage = decodeURIComponent(new URI(relativeToPackagePath).absoluteTo(packageFullPath).toString());
            console.log('pathRelativeToPackage: ' + pathRelativeToPackage);
            var fetchFunction = thisFetcher.fetchFileContentsText;
            if (fetchMode === 'blob') {
                fetchFunction = thisFetcher.fetchFileContentsBlob;
            } else if (fetchMode === 'data64uri') {
                fetchFunction = thisFetcher.fetchFileContentsData64Uri;
            }
            fetchFunction.call(thisFetcher, pathRelativeToPackage, fetchCallback, onerror);
        },

        getFileContentsFromPackage: function (fileRelativePath, callback) {
            var thisFetcher = this;
            thisFetcher.fetchFileContentsText(fileRelativePath, function (fileContents) {
                callback(fileContents);
            }, thisFetcher._handleError);
        },

        getContainerXml: function (callback) {
            var fileRelativePath = 'META-INF/container.xml';
            this.getFileContentsFromPackage(fileRelativePath, callback);
        },

        getXmlFileDom: function (xmlFileRelativePath, callback) {
            var thisFetcher = this;
            thisFetcher.getFileContentsFromPackage(xmlFileRelativePath, function (xmlFileContents) {
                var fileDom = thisFetcher.parseXml(xmlFileContents);
                callback(fileDom);
            });
        },

        getPackageFullPath: function (callback) {
            var thisFetcher = this;
            thisFetcher.getXmlFileDom('META-INF/container.xml', function (containerXmlDom) {
                thisFetcher.getRootFile(containerXmlDom, callback);
            });
        },

        getRootFile: function (containerXmlDom, callback) {
            var rootFile = $('rootfile', containerXmlDom);
            var packageFullPath = rootFile.attr('full-path');
            console.log('packageFullPath: ' + packageFullPath);
            callback(packageFullPath);
        },

        getPackageDom: function (callback) {
            var thisFetcher = this;
            if (thisFetcher.has('_packageDom')) {
                callback(thisFetcher.get('_packageDom'));
            } else {
                // TODO: use jQuery's Deferred
                // Register all callbacks interested in initialized packageDom, launch its instantiation only once
                // and broadcast to all callbacks registered during the initialization once it's done:
                if (thisFetcher.has('_packageDomInitializationSubscription')) {
                    thisFetcher.get('_packageDomInitializationSubscription').push(callback);
                } else {
                    thisFetcher.set('_packageDomInitializationSubscription', [callback]);
                    thisFetcher.getPackageFullPath(function (packageFullPath) {
                        thisFetcher.set('_packageFullPath', packageFullPath);
                        console.log('Have set _packageFullPath' + packageFullPath);
                        thisFetcher.getXmlFileDom(packageFullPath, function (packageDom) {
                            thisFetcher.set('_packageDom', packageDom);
                            var initializationSubscriptions = thisFetcher.get('_packageDomInitializationSubscription');
                            thisFetcher.unset('_packageDomInitializationSubscription');
                            initializationSubscriptions.forEach(function (subscriberCallback) {
                                subscriberCallback(packageDom);
                            });
                        })
                    });
                }
            }
        }

    });

    return ZipFetcher;
});
define('models/resource_resolver',['require', 'module', 'jquery', 'URIjs/URI', './fetch_base'], function (require, module, $, URI, EpubFetchBase) {
    console.log('resource_resolver module id: ' + module.id);

    var ResourceResolver = EpubFetchBase.extend({
        initialize: function (attributes) {
        },

        _resolveResourceElements: function (elemName, refAttr, contentDocumentDom, contentDocumentURI,
                                            resolutionDeferreds) {
            var thisResolver = this;
            var fetcher = thisResolver.get('_resourceFetcher');
            var resolvedElems = $(elemName + '[' + refAttr + ']', contentDocumentDom);

            resolvedElems.each(function (index, resolvedElem) {
                var refAttrVal = $(resolvedElem).attr(refAttr);
                var refAttrUri = new URI(refAttrVal);

                if (refAttrUri.scheme() === '') {
                    // Relative URI, fetch from packed EPUB archive:

                    var resolutionDeferred = $.Deferred();
                    resolutionDeferreds.push(resolutionDeferred);
                    var uriRelativeToZipRoot = refAttrUri.absoluteTo(contentDocumentURI).toString();

                    fetcher.relativeToPackageFetchFileContents(uriRelativeToZipRoot, 'blob', function (resourceData) {
                        $(resolvedElem).attr(refAttr, window.URL.createObjectURL(resourceData));
                        resolutionDeferred.resolve();
                    });
                }
            });
        },

        resolveInternalPackageResources: function (contentDocumentURI, contentDocumentType, contentDocumentText,
                                                   resolvedDocumentCallback) {
            var thisResolver = this;

            var contentDocumentDom = this.parseMarkup(contentDocumentText, contentDocumentType);

            var resolutionDeferreds = [];

            thisResolver._resolveResourceElements('img', 'src', contentDocumentDom, contentDocumentURI,
                resolutionDeferreds);
            thisResolver._resolveResourceElements('link', 'href', contentDocumentDom, contentDocumentURI,
                resolutionDeferreds);

            $.when.apply($, resolutionDeferreds).done(function () {
                resolvedDocumentCallback(contentDocumentDom);
            });


        }
    });

    return ResourceResolver;
});
define('models/package_fetcher',['require', 'module', './fetch_base', './discover_content_type', './plain_fetcher', './zip_fetcher',
    './resource_resolver'],
    function (require, module, EpubFetchBase, ContentTypeDiscovery, PlainExplodedFetcher, ZipFetcher,
              ResourceResolver) {
        console.log('package_fetcher module id: ' + module.id);


        var PackageFetcher = EpubFetchBase.extend({

            initialize: function (attributes) {
                var contentTypeDiscovery = new ContentTypeDiscovery({'contentUrl': this.get('packageDocumentURL')});
                this.set('_contentTypeDiscovery', contentTypeDiscovery);
                this._setupPackageContentType();
                this._setupResourceFetcher();
            },

            _setupPackageContentType: function () {
                this.set('_packageContentType', this.get('_contentTypeDiscovery').identifyContentType());
            },

            _getPackageReadStrategy: function () {
                var readStrategy = 'exploded';
                var packageContentType = this.getPackageContentType();
                if (packageContentType in this.constructor.contentTypePackageReadStrategyMap) {
                    readStrategy = this.constructor.contentTypePackageReadStrategyMap[packageContentType]
                }
                return readStrategy;
            },

            _setupResourceFetcher: function () {
                var thisFetcher = this;
                var packageReadStrategy = thisFetcher._getPackageReadStrategy();
                if (packageReadStrategy === 'exploded') {
                    console.log('using new PlainExplodedFetcher');
                    thisFetcher.set('_resourceFetcher', new PlainExplodedFetcher({
                        'baseUrl': thisFetcher.get('packageDocumentURL'),
                        '_contentTypeDiscovery': thisFetcher.get('_contentTypeDiscovery')
                    }));
                } else if (packageReadStrategy === 'zipped') {
                    console.log('using new ZipFetcher');
                    thisFetcher.set('_resourceFetcher', new ZipFetcher({
                        'baseUrl': thisFetcher.get('packageDocumentURL'),
                        '_contentTypeDiscovery': thisFetcher.get('_contentTypeDiscovery'),
                        'libDir': thisFetcher.get('libDir')
                    }));
                } else {
                    throw new Error('Unsupported package read strategy: ' + packageReadStrategy);
                }
                thisFetcher.set('_resourceResolver', new ResourceResolver({
                    '_resourceFetcher': thisFetcher.get('_resourceFetcher')
                }));
            },

            isPackageExploded: function () {
                return this.get('_resourceFetcher').isExploded();
            },

            resolveURI: function (epubResourceURI) {
                return this.get('_resourceFetcher').resolveURI(epubResourceURI);
            },

            relativeToPackageFetchFileContents: function (relativePath, fetchMode, fetchCallback, onerror) {
                this.get('_resourceFetcher').relativeToPackageFetchFileContents(relativePath, fetchMode, fetchCallback,
                    onerror);
            },

            getPackageContentType: function () {
                return this.get('_packageContentType');
            },

            getPackageDom: function (callback) {
                this.get('_resourceFetcher').getPackageDom(callback);
            },

            resolveInternalPackageResources: function (contentDocumentURI, contentDocumentType, contentDocumentText,
                                                       resolvedDocumentCallback) {
                this.get('_resourceResolver').resolveInternalPackageResources(contentDocumentURI, contentDocumentType,
                    contentDocumentText, resolvedDocumentCallback);
            }

        }, {
            contentTypePackageReadStrategyMap: {
                'application/oebps-package+xml': 'exploded',
                'application/epub+zip': 'zipped',
                'application/zip': 'zipped'
            }
        });

        return PackageFetcher;
    });
define('epub_fetch_module',['require', 'module', 'jquery', 'underscore', 'backbone', './models/package_fetcher' ],
    function (require, module, $, _, Backbone, PackageFetcher) {

        console.log('epub_fetch_module module id: ' + module.id);
        console.log(module.id + 'Backbone:' + Backbone);

        var EpubFetchModule = Backbone.Model.extend({
            initialize: function (attributes) {
                this.set('packageFetcher', new PackageFetcher({
                    packageDocumentURL: this.get('packageDocumentURL'),
                    libDir: this.get('libDir')
                }));
            },

            // Description: The public interface
            getPackageContentType: function () {
                return this.get('packageFetcher').getPackageContentType();
            },
            getPackageDom: function (callback) {
                this.get('packageFetcher').getPackageDom(callback);
            },
            getPackageDocumentURL: function (callback) {
                return this.get('packageDocumentURL');
            },
            isPackageExploded: function () {
                return this.get('packageFetcher').isPackageExploded();
            },
            resolveURI: function (epubResourceURI) {
                return this.get('packageFetcher').resolveURI(epubResourceURI);
            },
            relativeToPackageFetchFileContents: function (relativePath, fetchMode, fetchCallback, onerror) {
                this.get('packageFetcher').relativeToPackageFetchFileContents(relativePath, fetchMode, fetchCallback,
                    onerror);
            },
            resolveInternalPackageResources: function (contentDocumentURI, contentDocumentType, contentDocumentText,
                                                       resolvedDocumentCallback) {
                this.get('packageFetcher').resolveInternalPackageResources(contentDocumentURI, contentDocumentType,
                    contentDocumentText, resolvedDocumentCallback);
            }

        });
        return EpubFetchModule;
    });
